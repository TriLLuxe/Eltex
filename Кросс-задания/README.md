
# Задание 1: raw sockets + САОД + signals

Написать echo-client и echo-server на raw сокетах. Сервер должен отвечать клиенту то же самое сообщение + порядковый номер сообщения от этого клиента. Протокол сообщения - UDP.

Например:
Клиент 1 посылает на сервер сообщение “WAAAAAAAGH”
Сервер отвечает клиенту 1 “WAAAAAAAGH 1”
Клиент 1 посылает серверу сообщение “ping”
Сервер отвечает клиенту 1 “ping 2”
Клиент 2 посылает серверу сообщение “ping”
Сервер отвечает клиенту 2 “ping 1”
Клиент 1 посылает на сервер сообщение “WAAAAAAAGH”
Сервер отвечает клиенту 1 “WAAAAAAAGH 3”

При штатном выключении (в том числе при получении сигнала) клиент должен посылать серверу сообщение о закрытии, после получения этого сообщения сервер должен сбросить связанные с данным клиентом счетчики и при последующем подключении клиента с тем же ip:port, начинать отсчет с 1.


# Задание 2: fork + poll/epoll/select + timers + IPC

Управление такси.
Есть опорный пункт - исходное приложение. Запускается один раз и привязано к терминалу, имеет CLI.

В CLI должны быть команды create_driver, send_task <pid> <task_timer>, get_status <pid>, get_drivers.

create_driver создает новый процесс (driver), который ожидает команд от CLI, pid процесса будет использоваться  для обращения к этому driver.

send_task <pid> <task_timer> создаст задачу для driver номер <pid> и займет его на <task_timer> секунд. Если попытаться обратиться к этому driver во время выполнения задания с помощью send_task, то driver должен послать ошибку Busy <task_timer>. По истечению <task_timer> секунд driver меняет свое состояние на Available.

get_status <pid> показывает статус driver с номером <pid>. Может быть Busy <task_timer> либо Available.

get_drivers показывает статусы и pid всех drivers запущенных из этого инстанса CLI.

С таймерами нужно разобраться самостоятельно. Процесс не должен ожидать заданное время в цикле while без полезных действий.

Для вашего варианта задания предполагается использование:
- мультиплексирование с помощью функции select
- очереди сообщений System V